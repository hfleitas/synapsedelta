{
	"name": "SQLPoolMerge",
	"properties": {
		"content": {
			"query": "MERGE into target as t\nUSING (\n    SELECT * FROM lastchanges \n  ) as lc ([key], time, newvalue, deleted)\nON lc.[key] = t.[key]\nWHEN MATCHED AND lc.deleted = 1 \n    THEN DELETE\nWHEN MATCHED \n    THEN UPDATE SET t.[key] = lc.[key], t.[value] = lc.newValue\nWHEN NOT MATCHED AND lc.deleted = 0 \n    then INSERT ([key], [value]) VALUES(lc.[key], lc.newValue);\n\n/*\nInvalid column name 'true'. \nThe identifier 's.deleted' cannot be bound. \nOnly source columns and columns in the clause scope are allowed in the 'WHEN NOT MATCHED' clause of a MERGE statement. \nThe identifier 'false' cannot be bound. \nOnly source columns and columns in the clause scope are allowed in the 'WHEN NOT MATCHED' clause of a MERGE statement.\n*/\ngo\n\nCreate table target2hash\nwith (\n    distribution = hash([key]),\n    clustered columnstore index\n)\nas\nselect * from target\ngo\n\nMERGE into target2hash as t\nUSING (\n    SELECT * FROM lastchanges \n  ) as lc ([key], time, newvalue, deleted)\nON lc.[key] = t.[key]\nWHEN MATCHED AND lc.deleted = 1 \n    THEN DELETE\nWHEN MATCHED \n    THEN UPDATE SET t.[key] = lc.[key], t.[value] = lc.newValue\nWHEN NOT MATCHED AND lc.deleted = 0 \n    then INSERT ([key], [value]) VALUES(lc.[key], lc.newValue);\n\nselect * from target2hash;\n\n",
			"metadata": {
				"language": "sql"
			},
			"currentConnection": {
				"databaseName": "wplussynapsedw",
				"poolName": "wplussynapsedw"
			},
			"resultLimit": 5000
		},
		"type": "SqlQuery"
	}
}